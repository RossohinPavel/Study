""" Упражнение 1
Объявите функцию с именем get_even, которая принимает произвольное количество чисел в качестве аргументов и возвращает
список, составленный только из четных переданных значений.
Функцию выполнять не нужно, только определить.
Sample Input: 45 4 8 11 12 0
Sample Output: 4 8 12 0
"""
def get_even(*args):
    return [x for x in args if x  % 2 == 0]


""" Упражнение 2
Объявите функцию с именем get_biggest_city, которой можно передавать произвольное количество названий городов через 
аргументы. Данная функция должна возвращать название города наибольшей длины. Если таких городов несколько, то первый 
найденный (из наибольших). Программу реализовать без использования сортировки.
Функцию выполнять не нужно, только определить.
Sample Input: Питер Москва Самара Воронеж
Sample Output: Воронеж
"""
def get_biggest_city(*args):
    bc = ''
    for x in args:
        if len(x) > len(bc):
            bc = x
    return bc


""" Упражнение 3
Объявите функцию с именем get_data_fig для вычисления периметра произвольного N-угольника. На вход этой функции 
передаются N длин сторон через аргументы. Дополнительно могут быть указаны именованные аргументы:
    type - булево значение True/False
    color - целое числовое значение
    closed - булево значение True/False
    width - целое значение
Функция должна возвращать в виде кортежа периметр многоугольника и указанные значения именованных параметров в порядке 
их перечисления в тексте задания (если они были переданы). Если какой-либо параметр отсутствует, его возвращать не 
нужно (пропустить). Функцию выполнять не нужно, только определить.
"""
def get_data_fig(*args, **kwargs):
    s = sum(args)
    d = {'s': s, 'type': None, 'color': None, 'closed': None, 'width': None}
    for i in kwargs:
        d[i] = kwargs[i]
    lst = []
    for j in d.values():
        if j != None:
            lst.append(j)
    return tuple(lst)


""" Упражнение 4
(Для закрепления предыдущего материала). Вводится таблица целых чисел (см. пример ниже) размером N x N элементов 
(N определяется по входным данным). Эта таблица содержит нули, но кое-где - единицы. С помощью функции с именем verify, 
на вход которой передается двумерный список чисел, необходимо проверить, являются ли единицы изолированными друг от 
друга, то есть, вокруг каждой единицы должны быть нули. Рекомендуется следующий алгоритм. В функции verify производить 
перебор двумерного списка. Для каждого элемента (списка) со значением 1 вызывать еще одну вспомогательную функцию 
is_isolate для проверки изолированности единицы. То есть, функция is_isolate должна возвращать True, если единица 
изолирована и False - в противном случае.
Как только встречается не изолированная единица, функция verify должна возвращать False. Если успешно доходим 
(по элементам списка) до конца, то возвращается значение True. Функцию выполнять не нужно, только определить.
P. S. При реализации функции is_isolate не следует прописывать восемь операторов if. Подумайте, как это можно сделать 
красивее (с точки зрения реализации алгоритма). 
Sample Input:
    1 0 0 0 0
    0 0 1 0 0
    0 0 0 0 0
    0 1 0 1 0
    0 0 0 0 0
Sample Output: True
"""
def is_isolate(l):
    if 2 in l:
        return False
    for i in range(len(l) - 1):
        if l[i] == 1 and l[i + 1] == 1:
            return False
    return True
def verify(a):
    flag = True
    for i in range(len(a) - 1):
        lst = [a[i][x] + a[i + 1][x] for x in range(len(a[i]))]
        if is_isolate(lst) == False:
            flag = False
    return True if flag else False


""" Упражнение 5
(Для закрепления предыдущего материала). Объявите функцию с именем str_min, которая сравнивает две переданные строки и 
возвращает минимальную из них (то есть, выполняется лексикографическое сравнение строк). Затем, используя функциональный 
подход к программированию (то есть, более сложные функции реализуются путем вызова более простых), реализовать еще две 
аналогичные функции:
- с именем str_min3 для поиска минимальной строки из трех переданных строк;
- с именем str_min4 для поиска минимальной строки из четырех переданных строк.
Выполнять функции не нужно, только записать.
"""
def str_min(*args):
    return min(args)
def str_min3(*args):
    return min(args)
def str_min4(*args):
    return min(args)

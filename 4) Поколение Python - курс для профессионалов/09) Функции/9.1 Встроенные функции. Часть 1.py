""" Упражнение 1
Напишите программу, которая выводит все строчные латинские буквы.
Формат входных данных
На вход программе ничего не подается.
Формат выходных данных
Программа должна вывести все строчные латинские буквы от a до z, каждую на отдельной строке.
Примечание. В задаче удобно воспользоваться функциями ord() и chr().
"""
from string import ascii_lowercase as alc
print(*alc, sep='\n')


""" Упражнение 2
Реализуйте функцию convert(), которая принимает один аргумент:
    number — целое число
Функция должна возвращать кортеж из трех элементов, расположенных в следующем порядке:
    двоичное представление числа number в виде строки без префикса 0b
    восьмеричное представление числа number в виде строки без префикса 0o
    шестнадцатеричное представление числа number в виде строки в верхнем регистре без префикса 0x
Примечание 1. В задаче удобно воспользоваться функциями bin(), oct() и hex().
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию convert(), 
но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(convert(15))
Sample Output 1:
    ('1111', '17', 'F')
Sample Input 2:
    print(convert(-24))
Sample Output 2:
    ('-11000', '-30', '-18')
Sample Input 3:
    print(convert(1))
Sample Output 3:
    ('1', '1', '1')
"""
convert = lambda x: (bin(x).replace('0b', ''), oct(x).replace('0o', ''), hex(x).replace('0x', '').upper())


""" Упражнение 3
Вам доступен словарь films, ключом в котором является название некоторого фильма, а значением — словарь с оценками этого 
фильма от изданий imdb и kinopoisk.
Дополните приведенный ниже код, чтобы он вывел название фильма с наименьшей средней оценкой.
Примечание 1. Гарантируется, что искомый фильм единственный.
Примечание 2. Средней оценкой считается отношение суммы всех оценок к их количеству.
Примечание 3. В задаче удобно воспользоваться функцией min().
"""
films = {'Spider-Man: No Way Home': {'imdb': 8.8, 'kinopoisk': 8.3},
         'Don"t Look Up': {'imdb': 7.3, 'kinopoisk': 7.6},
         'Encanto': {'imdb': 7.3, 'kinopoisk': 7.4},
         'The Witcher': {'imdb': 8.2, 'kinopoisk': 7.3},
         'Ghostbusters: Afterlife': {'imdb': 7.3, 'kinopoisk': 8},
         'Harry Potter 20th Anniversary: Return to Hogwarts': {'imdb': 8.1, 'kinopoisk': 8.2},
         'Shingeki no Kyojin': {'imdb': 9.0, 'kinopoisk': 8.3},
         'The Matrix': {'imdb': 8.7, 'kinopoisk': 8.5},
         'The Dark Knight': {'imdb': 9.0, 'kinopoisk': 8.5},
         'The Shawshank Redemption': {'imdb': 9.3, 'kinopoisk': 9.1},
         'Avengers: Endgame': {'imdb': 8.4, 'kinopoisk': 7.7}}

print(min(films, key=lambda x: sum(films[x].values())))

""" Упражнение 4
Реализуйте функцию non_negative_even(),  которая принимает один аргумент:
    numbers — непустой список чисел
Функция должна возвращать True, если все числа в списке numbers являются четными и неотрицательными, или False в 
противном случае.
Примечание 1. В задаче удобно воспользоваться функцией all().
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию non_negative_even(), 
но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(non_negative_even([0, 2, 4, 8, 16]))
Sample Output 1:
    True
Sample Input 2:
    print(non_negative_even([-8, -4, -2, 0, 2, 4, 8]))
Sample Output 2:
    False
Sample Input 3:
    print(non_negative_even([0, 0, 0, 0, 0]))
Sample Output 3:
    True
"""
non_negative_even = lambda x: all(y % 2 == 0 and y >= 0 for y in x)


""" Упражнение 5
Реализуйте функцию is_greater(), которая принимает два аргумента в следующем порядке:
    lists — список, элементами которого являются списки целых чисел
    number — целое число
Функция должна возвращать True, если хотя бы в одном вложенном списке из списка lists сумма всех элементов больше 
number, или False в противном случае.
Примечание 1. В задаче удобно воспользоваться функцией any().
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию is_greater(), 
но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    data = [[-3, 4, 0, 1], [1, 1, -4], [0, 0], [9, 3]]
    
    print(is_greater(data, 10))
Sample Output 1:
    True
Sample Input 2:
    data = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]
    
    print(is_greater(data, 2))
Sample Output 2:
    False
Sample Input 3:
    data = [[0, 1, 2], [0, 3], [1, 1, 1], [3]]
    
    print(is_greater(data, 3))
Sample Output 3:
    False
"""
is_greater = lambda x, y: any(sum(i) > y for i in x)


""" Упражнение 6
Реализуйте функцию custom_isinstance(), которая принимает два аргумента в следующем порядке:
    objects — список произвольных объектов
    typeinfo — тип данных или кортеж с типами
Функция должна возвращать единственное число — количество объектов из списка objects, которые принадлежат типу typeinfo 
или одному из типов, если был передан кортеж.
Примечание 1. В задаче удобно воспользоваться функцией isinstance().
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию custom_isinstance(), 
но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    numbers = [1, 'two', 3.0, 'четыре', 5, 6.0]
    print(custom_isinstance(numbers, int))
Sample Output 1:
    2
Sample Input 2:
    numbers = [1, 'two', 3.0, 'четыре', 5, 6.0]
    print(custom_isinstance(numbers, (int, float)))
Sample Output 2:
    4
Sample Input 3:
    numbers = [1, 'two', 3.0, 'четыре', 5, 6.0]
    print(custom_isinstance(numbers, list))
Sample Output 3:
    0
"""
custom_isinstance = lambda x, y: len([i for i in x if isinstance(i, y)])


""" Упражнение 7
Вам доступен список numbers. Дополните приведенный ниже код, чтобы он вывел индекс максимального элемента в этом списке.
Примечание 1. Индексация начинается с нуля.
Примечание 2. В задаче удобно воспользоваться функциями enumerate() и max().
"""
numbers = [-7724, 5023, 3197, -102, -4129, -880, 5857, -2866, -8913, 1195, 9809, 5347, -8071, 903, 3030, -4347, -3354,
           1024, 8670, 4210, -5228, 8900, 4823, -2002, 4900, 9520, -3658, 1104, -9554, 3064, 9632, -8701, 3384, 4370,
           2034, 7822, -9694, 3347, 7440, -8459, 3238, -5193, -3381, 5281, 9022, 5559, 7593, -6540, -6204, -2483, 8729,
           5810, -8254, -9846, -1801, 4882, 3838, -3140, 7609, -3325, 6026, 2994, -1677, 1266, -1893, -4408, -5722,
           -2841, 9812, 5837, -7474, 4624, -664, 6998, 7888, -971, 8810, 3812, -5396, 2593, 512, -4634, 9735, -3062,
           9031, -9300, 3657, 6332, 7552, 8125, -725, 4392, 1727, 8194, -2828, -4314, -8967, -7912, -1363, -5957]
print(numbers.index(max(numbers)))


""" Упражнение 8
Функция my_pow()
Реализуйте функцию my_pow(), которая принимает один аргумент:
    number — целое неотрицательное число
Функция должна возвращать сумму, состоящую из цифр числа, возведенных в степень их порядкового номера.
Примечание 1. Рассмотрим число 139139 из первого теста. Сумма цифр этого числа, возведенных в степень их порядкового 
номера, равна:
1^1 + 3^2 + 9^3 = 739
Примечание 2. В задаче удобно воспользоваться функциями enumerate() и sum().
Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию my_pow(), но не код, 
вызывающий ее.
Примечание 4. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(my_pow(139))
Sample Output 1:
    739
Sample Input 2:
    print(my_pow(123))
Sample Output 2:
    32
Sample Input 3:
    print(my_pow(0))
Sample Output 3:
    0
"""
my_pow = lambda x: sum(int(v)**i for i, v in enumerate(str(x), 1))


""" Упражнение 9
Вам доступны три списка names, budgets и box_offices. Первый список содержит названия различных мультфильмов, второй и 
третий — соответствующие бюджеты и сборы в долларах.
Дополните приведенный ниже код, чтобы он определил, какую прибыль принес каждый мультфильм и вывел названия 
мультфильмов, указав для каждого соответствующую прибыль. Мультфильмы должны быть расположены в лексикографическом 
порядке, каждый на отдельной строке, в следующем формате:
    <фильм>: <прибыль>$
Примечание 1. Прибыль определяется как разность сборов и бюджета.
Примечание 2. Начальная часть ответа выглядит так:
    Cars: 342216280$
    Coco: 627082196$
    Finding Nemo: 846335536$
    ...
Примечание 3. В задаче удобно воспользоваться функцией zip().
"""
names = ['Moana', 'Cars', 'Zootopia', 'Ratatouille', 'Coco', 'Inside Out', 'Finding Nemo', 'Frozen']
budgets = [150000000, 120000000, 150000000, 150000000, 180000000, 175000000, 94000000, 150000000]
box_offices = [643331111, 462216280, 1023784195, 620702951, 807082196, 857611174, 940335536, 1280802282]
for name, st, ed in sorted(zip(names, box_offices, budgets)):
    print(f'{name}: {st-ed}$')


""" Упражнение 10
Как уже известно, функция zip() объединяет элементы различных последовательностей. Особенностью функции является то, 
что при передаче последовательностей различной длины элементы последовательности большей длины будут отброшены.
Реализуйте функцию zip_longest(), которая принимает переменное количество позиционных аргументов, каждый из которых 
является списком, и один необязательный именованный аргумент fill, имеющий значение по умолчанию None.
Функция должна объединять элементы переданных последовательностей в кортежи, аналогично функции zip(), и возвращать 
в виде списка, но если последовательности имеют различную длину, недостающие элементы последовательностей меньшей длины 
должны принимать значение fill.
Примечание 1. Рассмотрим первый тест со следующим вызовом:
    zip_longest([1, 2, 3, 4, 5], ['a', 'b', 'c'], fill='_')
Первый список имеет длину 5, второй — 3, то есть элементам 4 и 5 из первого списка нет пар из второго списка. В таком 
случае, функция должна сопоставить им значение fill, равное '_'. Итак, результатом работы функции будет список:
    [(1, 'a'), (2, 'b'), (3, 'c'), (4, '_'), (5, '_')]
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию zip_longest(), но не код, 
вызывающий ее. 
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(zip_longest([1, 2, 3, 4, 5], ['a', 'b', 'c'], fill='_'))
Sample Output 1:
    [(1, 'a'), (2, 'b'), (3, 'c'), (4, '_'), (5, '_')]
Sample Input 2:
    data = [[1, 2, 3, 4, 5], ['one', 'two', 'three'], ['I', 'II']]
    print(zip_longest(*data))
Sample Output 2:
    [(1, 'one', 'I'), (2, 'two', 'II'), (3, 'three', None), (4, None, None), (5, None, None)]
Sample Input 3:
    data = [[1, 2, 3, 4, 5], ['one', 'two', 'three', 'four', 'five'], ['I', 'II', 'III', 'IV', 'V']]
    print(zip_longest(*data))
Sample Output 3:
    [(1, 'one', 'I'), (2, 'two', 'II'), (3, 'three', 'III'), (4, 'four', 'IV'), (5, 'five', 'V')]
"""
zip_longest = lambda *args, fill=None: list(zip(*map(lambda x: x + [fill] * (len(max(args, key=len))-len(x)), args)))


""" Упражнение 11
Дана строка, содержащая латинские буквы и цифры. Напишите программу, которая сортирует символы в строке согласно 
следующим правилам:
    все отсортированные строчные буквы стоят перед заглавными буквами
    все отсортированные заглавные буквы стоят перед цифрами
    все отсортированные нечетные цифры стоят перед четными
Формат входных данных
На вход программе подается строка, содержащая латинские буквы и цифры.
Формат выходных данных
Программа должна расположить символы в строке в соответствии с условием задачи и вывести полученный результат.
Примечание. Тестовые данные доступны по ссылке.
Sample Input 1:
    Sorting1234
Sample Output 1:
    ginortS1324
Sample Input 2:
    n0tEast3rEgg
Sample Output 2:
    aggnrsttEE30
Sample Input 3:
    3DYrz34UXl
Sample Output 3:
    lrzDUXY334
"""
# Долбанутая однострочная функция сортировки
sl = lambda x: (x.islower(), x.isupper(), -ord(x) if x.isalpha() else (int(x) % 2, -ord(x)))
print(''.join(sorted(input(), key=sl, reverse=True)))

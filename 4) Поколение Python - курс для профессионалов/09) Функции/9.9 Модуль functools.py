""" Упражнение 1
Вам доступна уже реализованная функция send_email(), которая принимает три аргумента в следующем порядке:
    name — имя
    email_address — адрес электронной почты
    text — содержание письма
Функция отправляет письмо пользователю с именем name на адрес email_address с содержанием text.
1) Реализуйте функцию to_Timur() с помощью функции partial(), которая принимает один аргумент:
    text — содержание письма
Функция должна отправлять письмо пользователю с именем Тимур на адрес timyrik20@beegeek.ru с содержанием text.
2) Реализуйте функцию send_an_invitation() с помощью функции partial(), которая принимает два аргумента в следующем
порядке:
    name — имя
    email_address — адрес электронной почты
Функция должна отправлять письмо на имя name и на адрес email_address со следующим содержанием:
    Школа BEEGEEK приглашает Вас на новый курс по программированию на языке Python. тутут....
Примечание 1. Функции to_Timur() и send_an_invitation() должны являться partial объектами.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимые функции to_Timur() и
send_an_invitation(), но не код, вызывающий их.
Примечание 3. Тестовые данные доступны по ссылке.
"""
from functools import partial
to_Timur = partial(send_email, 'Тимур', 'timyrik20@beegeek.ru')
new_course_invite = 'Школа BEEGEEK приглашает Вас на новый курс по программированию на языке Python. тутут....'
send_an_invitation = partial(send_email, text=new_course_invite)


""" Упражнение 2
Дима решил выучить английский алфавит, и чтобы изучение шло быстрее, он придумал упражнение: он берет произвольное 
английское слово и расставляет в нем все буквы в лексикографическом порядке. Иногда Дима берет слова повторно, так как 
не помнит, брал ли их раньше.
Напишите программу, которая принимает на вход произвольное количество английских слов и в каждом расставляет буквы в 
лексикографическом порядке.
Форматы входных данных
На вход программе подается произвольное количество английских слов в нижнем регистре, каждое на отдельной строке. 
Форматы входных данных
Программа должна в каждом введенном слове расположить все буквы в лексикографическом порядке и вывести полученный 
результат. Слова должны быть расположены в исходном порядке, каждое на отдельной строке.
Примечание 1. Обратите внимание, что в задаче установлено ограничение по времени в одну секунду.
Примечание 2. Тестовые данные доступны по ссылке.
Sample Input 1:
    tutorial
    pattern
    add
Sample Output 1:
    ailorttu
    aenprtt
    add
Sample Input 2:
    forget
    forget
    forget
    forget
    imagine
Sample Output 2:
    efgort
    efgort
    efgort
    efgort
    aegiimn
"""
import sys
from functools import lru_cache
@lru_cache
def word_sort(word):
    return ''.join(sorted(word))
for i in sys.stdin:
    print(word_sort(i.strip()))


""" Упражнение 3
Дима любит учиться, но не любит получать низкие оценки, больше всего его огорчают двойки. Поэтому, когда Дима добирается 
до квартиры по лестнице, он поднимается исключительно на одну, три или четыре ступени, но не на две.
Реализуйте функцию ways(), которая принимает один аргумент:
n — натуральное число n ≤ 100
Функция должна возвращать единственное число — количество способов, которыми можно забраться на n-ую ступень. 
Путь начинается с первой ступени, подниматься можно исключительно на одну, три или четыре ступени.
Примечание 1. Рассмотрим первый тест. На пятую ступень можно забраться следующими четырьмя способами:
1 -> 2 -> 3 -> 4 -> 5
1 -> 4 -> 5
1 -> 2 -> 5
1 -> 5
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию ways(), но не код, 
вызывающий её.
Примечание 3. Обратите внимание, что в задаче установлено ограничение по времени в одну секунду.
Примечание 4. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(ways(5))
Sample Output 1:
    4
Sample Input 2:
    print(ways(1))
Sample Output 2:
    1
Sample Input 3:
    print(ways(2))
Sample Output 3:
    1
"""
# lru_cache работает как нам нужно, когда функция возвращает значение (если нет, в значение будет писаться None). Если
# мы будкм считать количество раз (через внешний счетчик), когда рекурсия дошла до нужного значения,
# то это может испортить правильный результат.
# Задача решается путем суммирования единиц. Это базовый случай рекурсивной функции, когда она при вычитании из n
# ступенек шагов достигла значения 1. С этой ступеньки был начат отсчет. Логика вызова рекурсии следующая.
# вычитаем из числа n - 4 и попадаем снова в функцию. Если у нас аргумент n вторго вызова рекурсии равен 1
# (мы достигли нужной нам ступеньки), то возвращаем 1. Если n меньше, то возвращаем 0 (так как мы перелетели через
# нужную нам ступеньку). Если наша n не удовлетворила этим 2 условиям то снова пытаемся вычесть 4. Соотвественно, когда
# вычитание 4 вернет нам какое - либо значение, рекурсия сворачивается и продолжается выполняться следующий за ней
# рекурсивный вызов.
# для ways(5) порядок вызовов будет следующим:
# 1) ways(5-4) -> получаем 1. Достигнут базовый случай. На 1 уровне вызовов 4 выпала из подсчета. На этом уровне
# остаются ways(n - 3) и ways(n - 1). Двигаемся по ним.
# 2) ways(5-3) получаем 2 и попадаем на рекурсивный вызов - 2 уровень. И по новой, пробуем вычесть 4 -> 0, 3 -> 0,
# и ways(2 - 1) -> дает на 1, попадаем на 3 уровень рекурсии. Там уже ловим базовый случай и рекурсия сворачивается.
# 3) ways(5-1) -> ways(4-3) эти вызовы дадут нам добраться до 1 и получить ее.
# 4) ways(5-1)-> ways(4-1) -> ways(3-1) -> ways(2-1)
# Получаем 4 способа. Кеш в этом случае запомнит все варианты вызовов, но повторно высчитывать ways(5-1) и ways(2-1)
# их не будет и возьмет значения из памяти
from functools import lru_cache
@lru_cache
def ways(n):
    if n == 1:
        return 1
    elif n < 1:
        return 0
    return ways(n - 4) + ways(n - 3) + ways(n - 1)
# нужно больше задачек на рекурсию и мемоизацию. Функционал очень полезен.

""" Упражнение 1
Реализуйте функцию sum_of_digits(), которая принимает один аргумент:
iterable — итерируемый объект, элементами которого являются натуральные числа
Функция должна возвращать единственное число — сумму цифр всех чисел, присутствующих в итерируемом объекте iterable.
Примечание 1. Рассмотрим набор чисел 13, 20, 41, 2, 2, 513,20,41,2,2,5 из первого теста. Сумма цифр всех представленных
чисел будет равна:
1 + 3 + 2 + 0 + 4 + 1 + 2 + 2 + 5 = 20
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию sum_of_digits(), но не код,
вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(sum_of_digits([13, 20, 41, 2, 2, 5]))
Sample Output 1:
    20
Sample Input 2:
    print(sum_of_digits((1, 2, 3, 4, 5, 6, 7, 8, 9, 10)))
Sample Output 2:
    46
Sample Input 3:
    print(sum_of_digits([123456789]))
Sample Output 3:
    45
"""
import itertools as it

def sum_of_digits(iterable):
    return sum(map(int, it.chain.from_iterable(map(str, iterable))))


""" Упражнение 2
Реализуйте функцию is_rising(), которая принимает один аргумент:
iterable — итерируемый объект, элементами которого являются числа
Функция должна возвращать True, если элементы итерируемого объекта расположены строго по возрастанию, 
или False в противном случае.
Примечание 1. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством, 
а также содержит не менее двух элементов.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию is_rising(), 
но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(is_rising([1, 2, 3, 4, 5]))
Sample Output 1:
    True
Sample Input 2:
    iterator = iter([1, 1, 1, 2, 3, 4])
    
    print(is_rising(iterator))
Sample Output 2:
    False
Sample Input 3:
    iterator = iter(list(range(100, 200)))
    
    print(is_rising(iterator))
Sample Output 3:
    True
"""
import itertools as it

def is_rising(iterable):
    return all(map(lambda x: x[0]<x[1], it.pairwise(iterable)))


""" Упражнение 3
Реализуйте функцию max_pair(), которая принимает один аргумент:
iterable — итерируемый объект, элементами которого являются числа
Функция должна возвращать единственное число — максимальную сумму двух соседних чисел итерируемого объекта iterable.
Примечание 1. Рассмотрим список чисел 1, 8, 2, 4, 3 из первого теста. Из данной последовательности можно 
получить следующие пары соседних элементов: 1 и 8, 8 и 2, 2 и 4, 4 и 3. Максимальную сумму имеет вторая пара — 10.
Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством, 
а также содержит не менее двух элементов.
Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию max_pair(), 
но не код, вызывающий ее.
Примечание 4. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(max_pair([1, 8, 2, 4, 3]))
Sample Output 1:
    10
Sample Input 2:
    iterator = iter([1, 2, 3, 4, 5])
    
    print(max_pair(iterator))
Sample Output 2:
    9
Sample Input 3:
    iterator = iter([0, 0, 0, 0, 0, 0, 0, 0, 0])
    
    print(max_pair(iterator))
Sample Output 3:
    0
"""
import itertools as it

max_pair = lambda iterable: max(map(sum, it.pairwise(iterable)))


""" Упражнение 4
Реализуйте функцию ncycles(), которая принимает два аргумента в следующем порядке:
iterable — итерируемый объект
times — натуральное число
Функция должна возвращать итератор, генерирующий последовательность элементов итерируемого объекта iterable, 
зацикленных times раз.
Примечание 1. Элементы итерируемого объекта в возвращаемом функцией итераторе должны располагаться в своем 
исходном порядке.
Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию ncycles(), 
но не код, вызывающий ее.
Примечание 4. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(*ncycles([1, 2, 3, 4], 3))
Sample Output 1:
    1 2 3 4 1 2 3 4 1 2 3 4
Sample Input 2:
    iterator = iter('bee')
    
    print(*ncycles(iterator, 4))
Sample Output 2:
    b e e b e e b e e b e e
Sample Input 3:
    iterator = iter([1])
    
    print(*ncycles(iterator, 10))
Sample Output 3:
    1 1 1 1 1 1 1 1 1 1
"""
import itertools as it

ncycles = lambda iterable, times: it.chain(*it.tee(iterable, times))


""" Упражнение 5
Реализуйте функцию grouper(), которая принимает два аргумента в следующем порядке:
iterable — итерируемый объект
n — натуральное число
Функция должна возвращать итератор, генерирующий последовательность, элементами которой являются объединенные в кортежи 
по n элементов соседние элементы итерируемого объекта iterable. Если у элемента не достаточно соседей, то ими 
становится значение None.
Примечание 1. Элементы итерируемого объекта в возвращаемом функцией итераторе должны располагаться в своем исходном 
порядке.
Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию grouper(), 
но не код, вызывающий ее.
Примечание 4. Тестовые данные доступны по ссылке.
Sample Input 1:
    numbers = [1, 2, 3, 4, 5, 6]
    
    print(*grouper(numbers, 2))
Sample Output 1:
    (1, 2) (3, 4) (5, 6)
Sample Input 2:
    iterator = iter([1, 2, 3, 4, 5, 6, 7])
    
    print(*grouper(iterator, 3))
Sample Output 2:
    (1, 2, 3) (4, 5, 6) (7, None, None)
Sample Input 3:
    iterator = iter([1, 2, 3])
    
    print(*grouper(iterator, 5))
Sample Output 3:
    (1, 2, 3, None, None)
"""
# если в функцию zip передать один итератор несколько раз zip([iter, iter]), то функция за кулисами будет отбирать
# из него элементы поочередно.
# Пример: итератор i = iter([1, 2, 3, 4, 5, 6]) передаем в функцию zip, как zip(i, i), то получаем на выходе
# группированные кортежи (1, 2) (3, 4) (5, 6). Если передать 3 ссылки zip(i, i, i), -> (1, 2, 3) (4, 5, 6)
import itertools as it

def grouper(iterable, n):
    iterable = iter(iterable)
    return it.zip_longest(*(iterable for _ in range(n)))

""" Упражнение 1
Реализуйте функцию filterfalse() с использованием функции filter(), которая принимает два аргумента:
    predicate — функция-предикат; если имеет значение None, то работает аналогично функции bool()
    iterable — итерируемый объект
Функция должна работать противоположно функции filter(), то есть возвращать итератор, элементами которого являются
элементы итерируемого объекта iterable, для которых функция predicate вернула значение False.
Примечание 1. Предикат — это функция, которая возвращает True или False в зависимости от переданного в качестве
аргумента значения.
Примечание 2. Элементы итерируемого объекта в возвращаемом функцией итераторе должны располагаться в своем исходном
порядке.
Примечание 3. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
Примечание 4. В тестирующую систему сдайте программу, содержащую только необходимую функцию filterfalse(),
но не код, вызывающий ее.
Примечание 5. Тестовые данные доступны по ссылке.
Sample Input 1:
    objects = [0, 1, True, False, 17, []]

    print(*filterfalse(None, objects))
Sample Output 1:
    0 False []
Sample Input 2:
    numbers = (1, 2, 3, 4, 5)

    print(*filterfalse(lambda x: x % 2 == 0, numbers))
Sample Output 2:
    1 3 5
Sample Input 3:
    numbers = [1, 2, 3, 4, 5]

    print(*filterfalse(lambda x: x >= 3, numbers))
Sample Output 3:
    1 2
"""
def filterfalse(predicate, iterable):
    if predicate is None:
        predicate = bool
    return filter(lambda x: not predicate(x), iterable)


""" Упражнение 2
Транспонированная матрица — матрица A^T, полученная из исходной матрицы A заменой строк на столбцы. Например, если 
A = \begin{pmatrix} 1 \quad 2 \quad 3 \\ 4 \quad 5 \quad 6 \\ 7 \quad 8 \quad 9 \end{pmatrix}
A= 123, 456, 789, то A^T = 147, 258, 369
То есть для получения транспонированной матрицы из исходной нужно каждую строчку исходной матрицы записать в виде 
столбца в том же порядке.
Реализуйте функцию transpose() с использованием функции zip(), которая принимает один аргумент:
    matrix — матрица произвольной размерности
Функция должна возвращать транспонированную матрицу matrix.
Примечание 1. Под матрицей подразумеваются исключительно вложенные списки.
Примечание 2. Функция должна возвращать новую матрицу, а не изменять переданную.
Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию transpose(), 
но не код, вызывающий ее.
Примечание 4. Тестовые данные доступны по ссылке.
Sample Input 1:
    matrix = [[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]]
    
    for row in transpose(matrix):
        print(row)
Sample Output 1:
    [1, 4, 7]
    [2, 5, 8]
    [3, 6, 9]
Sample Input 2:
    matrix = [[1, 2, 3, 4, 5],
              [6, 7, 8, 9, 10]]
    
    for row in transpose(matrix):
        print(row)
Sample Output 2:
    [1, 6]
    [2, 7]
    [3, 8]
    [4, 9]
    [5, 10]
"""
def transpose(matrix):
    return [list(x) for x in zip(*matrix)]


""" Упражнение 3
Реализуйте функцию get_min_max() c использованием функции enumerate(), которая принимает один аргумент:
    data — список произвольных объектов, сравнимых между собой
Функция должна возвращать кортеж, в котором первым элементом является индекс минимального элемента в списке data, 
вторым — индекс максимального элемента в списке data. Если список data пуст, функция должна вернуть значение None.
Примечание 1. Если минимальных / максимальных элементов несколько, следует вернуть индексы первого по порядку элемента.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию get_min_max(), но не код, 
вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    data = [2, 3, 8, 1, 7]
    
    print(get_min_max(data))
Sample Output 1:
    (3, 2)
Sample Input 2:
    data = [1, 1, 2, 3, 8, 8]
    
    print(get_min_max(data))
Sample Output 2:
    (0, 4)
Sample Input 3:
    data = [9]
    
    print(get_min_max(data))
Sample Output 3:
    (0, 0)
"""
# Через индексы
def get_min_max(data):
    if data:
        return data.index(min(data)), data.index(max(data))
    else:
        return None

# Через enumerate
def get_min_max(data):
    if data:
        return min(enumerate(data), key=lambda x: x[1])[0], max(enumerate(data), key=lambda x: x[1])[0]


""" Упражнение 4 
Реализуйте функцию get_min_max(), которая принимает один аргумент:
iterable — итерируемый объект, элементы которого сравнимы между собой
Функция должна возвращать кортеж, в котором первым элементом является минимальный элемент итерируемого объекта iterable, 
вторым — максимальный элемент итерируемого объекта iterable. Если итерируемый объект iterable пуст, функция должна 
вернуть значение None.
Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию get_min_max(), 
но не код, вызывающий ее.
Примечание 2. Тестовые данные доступны по ссылке.
Sample Input 1:
    iterable = iter(range(10))
    
    print(get_min_max(iterable))
Sample Output 1:
    (0, 9)
Sample Input 2:
    iterable = [6, 4, 2, 33, 19, 1]
    
    print(get_min_max(iterable))
Sample Output 2:
    (1, 33)
Sample Input 3:
    iterable = iter([])
    
    print(get_min_max(iterable))
Sample Output 3:
    None
"""
def get_min_max(iterable):
    itr = iter(iterable)
    try:
        mn = next(itr)
        mx = mn
        for i in itr:
            if i < mn:
                mn = i
            elif i > mx:
                mx = i
        return mn, mx
    except StopIteration:
        return None


""" Упражнение 5
Как известно, функция map() принимает функцию и итерируемый объект и возвращает итератор, элементами которого являются 
элементы итерируемого объекта, к которым была применена переданная функция. Нередко элементами итерируемого объекта 
являются коллекции (списки, кортежи, ..), тогда внутри переданной функции нам приходится обращаться к каждому элементу 
этих коллекций по индексу. Например:
persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')]
full_names = map(lambda tup: tup[0] + ' ' + tup[1], persons)
Было бы удобно иметь функцию, назовем ее starmap(), которая бы принимала функцию не с одним аргументом, 
а с несколькими — каждым элементом коллекции:
    persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')]
    full_names = starmap(lambda name, surname: f'{name} {surname}', persons)
Реализуйте функцию starmap() с использованием функции map(), которая принимает два аргумента:
    func — функция
    iterable — итерируемый объект, элементами которого являются коллекции
Функция starmap() должна работать аналогично функции map(), то есть возвращать итератор, элементами которого являются 
элементы итерируемого объекта iterable, к которым была применена функция func, с единственным отличием: func должна 
принимать не один аргумент — коллекцию (элемент iterable), а каждый элемент этой коллекции в качестве самостоятельного 
аргумента.
Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию starmap(), но не код, 
вызывающий ее.
Примечание 2. Тестовые данные доступны по ссылке.
Sample Input 1:
    pairs = [(1, 3), (2, 5), (6, 4)]
    
    print(*starmap(lambda a, b: a + b, pairs))
Sample Output 1:
    4 7 10
Sample Input 2:
    points = [(1, 1, 1), (1, 1, 2), (2, 2, 3)]
    
    print(*starmap(lambda x, y, z: x * y * z, points))
Sample Output 2:
    1 2 12
"""


""" Упражнение 1
Реализуйте генераторную функцию simple_sequence(), которая не принимает никаких аргументов.
Функция должна возвращать генератор, порождающий бесконечную возрастающую последовательность натуральных чисел,
в которой каждое число встречается столько раз, каково оно:
1, 2, 2, 3, 3, 3, 4, 4, 4, 4, ..
Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую генераторную функцию
simple_sequence(), но не код, вызывающий ее.
Примечание 2. Тестовые данные доступны по ссылке.
    Sample Input 1:

    generator = simple_sequence()

    print(next(generator))
    print(next(generator))
Sample Output 1:
    1
    2
Sample Input 2:
    generator = simple_sequence()
    numbers = [next(generator) for _ in range(10)]

    print(*numbers)
Sample Output 2:
    1 2 2 3 3 3 4 4 4 4
"""
def simple_sequence():
    value = 0
    while True:
        value += 1
        for i in range(1, value +1):
            yield value


""" Упражнение 2
Реализуйте генераторную функцию alternating_sequence(), которая принимает один аргумент:
count — натуральное число, по умолчанию имеет значение None
Если count имеет значение None, функция должна возвращать генератор, порождающий бесконечный знакочередующийся 
ряд натуральных чисел.
Если count имеет в качестве значения натуральное число, функция должна возвращать генератор, порождающий первые 
count чисел знакочередующегося ряда натуральных чисел, а затем возбуждающий исключение StopIteration.
Примечание 1. Знакочередующийся ряд натуральных чисел имеет вид:
1, -2, 3, -4, 5, -6, 7, -8, 9, -10, ...
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую генераторную  функцию 
alternating_sequence(), но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    generator = alternating_sequence()
    
    print(next(generator))
    print(next(generator))
Sample Output 1:
    1
    -2
Sample Input 2:
    generator = alternating_sequence(10)
    
    print(*generator)
Sample Output 2:
    1 -2 3 -4 5 -6 7 -8 9 -10
"""
def alternating_sequence(count=None):
    x = 0
    while True:
        x += 1
        if not count is None and x == count +1:
            return
        yield x if x % 2 == 1 else -x


""" Упражнение 3
Реализуйте генераторную функцию primes(), которая принимает два аргумента в следующем порядке:
    left — натуральное число
    right — натуральное число
Функция должна возвращать генератор, порождающий последовательность простых чисел от left до right включительно, 
а затем возбуждающий исключение StopIteration.
Примечание 1. Гарантируется, что left <= right.
Примечание 2. Простое число — натуральное число, имеющее ровно два различных натуральных делителя — единицу и самого 
себя. Единица простым числом не является. 
Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую генераторную функцию primes(), 
но не код, вызывающий ее.
Примечание 4. Тестовые данные доступны по ссылке.
Sample Input 1:
    generator = primes(1, 15)
    
    print(*generator)
Sample Output 1:
    2 3 5 7 11 13
Sample Input 2:
    generator = primes(6, 36)
    
    print(next(generator))
    print(next(generator))
Sample Output 2:
    7
    11
"""
def is_primal(num):
    flag = False
    for i in range(2, num+1):
        if i == num and num % i == 0:
            flag = True
        if num % i == 0:
            break
    return flag

def primes(left, right):
    for i in range(left, right+1):
        if is_primal(i):
            yield i


""" Упражнение 4
Реализуйте генераторную функцию reverse(), которая принимает один аргумент:
sequence — последовательность
Функция должна возвращать генератор, порождающий элементы последовательности sequence в обратном порядке, а затем 
возбуждающий исключение StopIteration.
Примечание 1. Последовательностью является коллекция, поддерживающая индексацию и имеющая длину. Например, объекты 
типа list, str, tuple являются последовательностями.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую генераторную функцию reverse(), 
но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(*reverse([1, 2, 3, 4, 5]))
    Sample Output 1:
    
    5 4 3 2 1
Sample Input 2:
    generator = reverse('beegeek')
    
    print(type(generator))
    print(*generator)
Sample Output 2:
    <class 'generator'>
    k e e g e e b
"""
def reverse(sequence):
    x = len(sequence)
    while x > 0:
        x -= 1
        yield sequence[x]


""" Упражнение 5
Реализуйте генераторную функцию dates(), которая принимает два аргумента в следующем порядке:
    start — дата, тип date
    count — натуральное число, по умолчанию имеет значение None
Если count имеет значение None, функция должна возвращать генератор, порождающий последовательность из максимально 
допустимого количества дат (тип date), начиная с даты start.
Если count имеет в качестве значения натуральное число, функция должна возвращать генератор, порождающий 
последовательность из count дат (тип date), начиная с даты start, а затем возбуждающий исключение StopIteration.
Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую генераторную функцию dates(), 
но не код, вызывающий ее.
Примечание 2. Тестовые данные доступны по ссылке.
    Sample Input 1:
    
    generator = dates(date(2022, 3, 8))
    
    print(next(generator))
    print(next(generator))
    print(next(generator))
Sample Output 1:
    2022-03-08
    2022-03-09
    2022-03-10
Sample Input 2:
    generator = dates(date(2022, 3, 8), 5)
    
    print(*generator)
Sample Output 2:
    2022-03-08 2022-03-09 2022-03-10 2022-03-11 2022-03-12
"""
from datetime import date

def dates(start, end=None):
    start = start.toordinal()
    x = 0
    while True:
        if x + start == 3652060:
            return
        if not end is None and x == end:
            return
        yield date.fromordinal(start+x)
        x += 1


""" Упражнение 6
Реализуйте генераторную функцию card_deck(), которая принимает один аргумент:
suit — одна из четырех карточных мастей: пик, треф, бубен, червей
Функция должна возвращать генератор, циклично порождающий колоду игральных карт без масти suit. Каждая карта должна 
представлять собой строку в следующем формате:
<номинал> <масть>
Например, 7 пик, валет треф, дама бубен, король червей, туз пик.
Примечание 1. Карты, генерируемые итератором, должны располагаться сначала по величине номинала, затем масти.
Примечание 2. Старшинство мастей по возрастанию: пики, трефы, бубны, червы. Старшинство карт в масти по возрастанию: 
двойка, тройка, четверка, пятерка, шестерка, семерка, восьмерка, девятка, десятка, валет, дама, король, туз.
Примечание 3. Масти не требуют склонения и независимо от номинала должны сохранять следующее написание: 
пик, треф, бубен, червей.
Примечание 4. В тестирующую систему сдайте программу, содержащую только необходимую генераторную функцию card_deck(), 
но не код, вызывающий ее.
Примечание 5. Тестовые данные доступны по ссылке.
Sample Input 1:
    generator = card_deck('пик')
    
    print(next(generator))
    print(next(generator))
    print(next(generator))
Sample Output 1:
    2 треф
    3 треф
    4 треф
Sample Input 2:
    generator = card_deck('треф')
    cards = [next(generator) for _ in range(40)]
    
    print(*cards)
Sample Output 2:
    2 пик 3 пик 4 пик 5 пик 6 пик 7 пик 8 пик 9 пик 10 пик валет пик дама пик король пик туз пик 2 бубен 3 бубен 4 бубен 
    5 бубен 6 бубен 7 бубен 8 бубен 9 бубен 10 бубен валет бубен дама бубен король бубен туз бубен 2 червей 3 червей 
    4 червей 5 червей 6 червей 7 червей 8 червей 9 червей 10 червей валет червей дама червей король червей туз червей 
    2 пик
"""
def card_deck(suit):
    mark = [x for x in ("пик", "треф", "бубен", "червей") if x != suit]
    values = ("2", "3", "4", "5", "6", "7", "8", "9", "10", "валет", "дама", "король", "туз")
    while True:
        for m in mark:
            for v in values:
                yield f'{v} {m}'


""" Упражнение 7
Вам доступна генераторная функция matrix_by_elem(), которая принимает в качестве аргумента матрицу произвольной 
размерности и возвращает генератор, порождающий последовательность элементов переданной матрицы.
Перепишете данную функцию с использованием конструкции yield from, чтобы она выполняла ту же задачу.
Примечание 1. Под матрицей подразумеваются исключительно вложенные списки.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую генераторную функцию 
matrix_by_elem(), но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input:
    matrix = [[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]]
    
    print(*matrix_by_elem(matrix))
Sample Output:
    1 2 3 4 5 6 7 8 9
"""
def matrix_by_elem(matrix):
    for row in matrix:
        yield from row


""" Упражнение 8
Реализуйте генераторную функцию palindromes(), которая не принимает никаких аргументов.
Функция должна возвращать генератор, порождающий бесконечную последовательность натуральных чисел-палиндромов.
Примечание 1. Число-палиндром — число, которое читается одинаково как справа налево, так и слева направо.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую генераторную функцию palindromes(), 
но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    generator = palindromes()
    
    print(next(generator))
    print(next(generator))
    print(next(generator))
Sample Output 1:
    1
    2
    3
Sample Input 2:
    generator = palindromes()
    numbers = [next(generator) for _ in range(30)]
    
    print(*numbers)
Sample Output 2:
    1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101 111 121 131 141 151 161 171 181 191 202 212
"""
def palindromes():
    x = 0
    while True:
        x += 1
        if str(x) == str(x)[::-1]:
            yield x


""" Упражнение 9
Реализуйте генераторную функцию flatten(), которая принимает один аргумент:
nested_list — список, элементами которого являются целые числа или списки, элементами которых, в свою очередь, 
также являются либо целые числа, либо списки; вложенность может быть произвольной
Функция должна возвращать генератор, порождающий все числа, содержащиеся в nested_list, включая все числа из всех 
вложенных списков, а затем возбуждает исключение StopIteration.
Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую генераторную функцию flatten(), 
но не код, вызывающий ее.
Примечание 2. Тестовые данные доступны по ссылке.
Sample Input 1:
    generator = flatten([[1, 2], [[3]], [[4], 5]])
    
    print(*generator)
Sample Output 1:
    1 2 3 4 5
Sample Input 2:
    generator = flatten([1, 2, 3, 4, 5, 6, 7])
    
    print(*generator)
Sample Output 2:
    1 2 3 4 5 6 7
"""
def flatten(nested_list):
    for i in nested_list:
        if isinstance(i, int):
            yield i
        else:
            yield from flatten(i)

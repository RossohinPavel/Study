""" Упражнение 1
Вам доступна генераторная функция cubes_of_odds(), принимающая в качестве аргумента итерируемый объект, элементами
которого являются целые числа, и возвращающая генератор, порождающий последовательность нечетных чисел переданного
итерируемого объекта, возведенных в третью степень.
Перепишите данную функцию с использованием генераторного выражения, чтобы она выполняла ту же задачу.
Примечание 1. Если генераторное выражение становится достаточно большим, его можно записать в виде нескольких строк.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию cubes_of_odds(), но не код,
вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(*cubes_of_odds([1, 2, 3, 4, 5]))
Sample Output 1:
    1 27 125
Sample Input 2:
    evens = [2, 4, 6, 8, 10]

    print(list(cubes_of_odds(evens)))
Sample Output 2:
    []
"""
def cubes_of_odds(iterable):
    return (x**3 for x in iterable if x % 2 == 1)


""" Упражнение 2
Реализуйте генераторную функцию is_prime() с использованием генераторных выражений, которая принимает один аргумент:
number — натуральное число
Функция должна возвращать True, если число number является простым, или False в противном случае.
Примечание 1. Простое число — натуральное число, имеющее ровно два различных натуральных делителя — единицу и самого 
себя.
Примечание 2. В задаче удобно воспользоваться функциями all() или any(). 
Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию is_prime(), но не код, 
вызывающий ее.
Примечание 4. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(is_prime(7))
Sample Output 1:
    True
Sample Input 2:
    print(is_prime(8))
Sample Output 2:
    False
Sample Input 3:
    print(is_prime(1))
Sample Output 3:
    False
"""
is_prime = lambda num: all(1 if (x == 1 or x == num) and num != 1 else 0 for x in range(1, num+1) if num%x == 0)


""" Упражнение 3
Реализуйте функцию count_iterable() с использованием генераторных выражений, которая принимает один аргумент:
    iterable — итерируемый объект
Функция должна возвращать единственное число — количество элементов итерируемого объекта iterable.
Примечание 1. Гарантируется, что передаваемый в функцию итерируемый объект является конечным.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию count_iterable(), 
но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(count_iterable([1, 2, 3, 4, 5]))
Sample Output 1:
    5
Sample Input 2:
    numbers = iter([1, 2, 3, 4, 5, 6, 7])
    
    print(count_iterable(numbers))
Sample Output 2:
    7
Sample Input 3:
    data = tuple(range(432, 3845, 17))
    
    print(count_iterable(data))
Sample Output 3:
    201
"""
count_iterable = lambda x: sum(1 for _ in x)


""" Упражнение 4
Реализуйте генераторную функцию all_together() с использованием генераторных выражений, которая принимает произвольное 
количество позиционных аргументов, каждый из которых является итерируемым объектом.
Функция должна возвращать генератор, порождающий каждый элемент всех переданных итерируемых объектов: сначала все 
элементы первого итерируемого объекта, затем второго, и так далее.
Примечание 1. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию all_together(), 
но не код, вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылке.
Sample Input 1:
    objects = [range(3), 'bee', [1, 3, 5], (2, 4, 6)]
    
    print(*all_together(*objects))
Sample Output 1:
    0 1 2 b e e 1 3 5 2 4 6
Sample Input 2:
    objects = [[1, 2, 3], [(0, 0), (1, 1)], {'geek': 1}]
    
    print(*all_together(*objects))
Sample Output 2:
    1 2 3 (0, 0) (1, 1) geek
Sample Input 3:
    print(list(all_together()))
Sample Output 3:
    []
"""
all_together = lambda *num: (x for i in num for x in i)


""" Упражнение 5
Реализуйте генераторную функцию interleave() с использованием генераторных выражений, которая принимает произвольное 
количество позиционных аргументов, каждый из которых является последовательностью.
Функция должна возвращать генератор, порождающий каждый элемент всех переданных последовательностей: сначала первый 
элемент первой последовательности, затем первый элемент второй последовательности, и так далее; после второй элемент 
первой последовательности, затем второй элемент второй последовательности, и так далее.
Примечание 1. Последовательностью является коллекция, поддерживающая индексацию и имеющая длину. Например, объекты типа 
list, str, tuple являются последовательностями.
Примечание 2. Гарантируется, что все последовательности, передаваемые в функцию, имеют равные длины.
Примечание 3. Гарантируется, что в функцию всегда подается хотя бы одна последовательность.
Примечание 4. В тестирующую систему сдайте программу, содержащую только необходимую функцию interleave(), 
но не код, вызывающий ее.
Примечание 5. Тестовые данные доступны по ссылке.
Sample Input 1:
    print(*interleave('bee', '123'))
Sample Output 1:
    b 1 e 2 e 3
Sample Input 2:
    numbers = [1, 2, 3]
    squares = [1, 4, 9]
    qubes = [1, 8, 27]
    
    print(*interleave(numbers, squares, qubes))
Sample Output 2:
    1 1 1 2 4 8 3 9 27
"""
interleave = lambda *coll: (coll[y][x] for x in range(len(coll[0])) for y in range(len(coll)))

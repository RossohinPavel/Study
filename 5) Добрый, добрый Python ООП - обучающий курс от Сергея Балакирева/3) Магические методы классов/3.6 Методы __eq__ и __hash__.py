""" Упражнение 1
Подвиг 4. Объявите в программе класс с именем Rect (прямоугольник), объекты которого создаются командой:
    rect = Rect(x, y, width, height)
где x, y - координата верхнего левого угла (числа: целые или вещественные); width, height - ширина и высота
прямоугольника (числа: целые или вещественные).
В этом классе определите магический метод, чтобы хэши объектов класса Rect с равными width, height были равны. Например:
    r1 = Rect(10, 5, 100, 50)
    r2 = Rect(-10, 4, 100, 50)

    h1, h2 = hash(r1), hash(r2)   # h1 == h2
P.S. На экран ничего выводить не нужно, только объявить класс.
"""
class Rect:
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

    def __hash__(self):
        return hash((self.width, self.height))


""" Упражнение 2
Подвиг 6. Объявите класс с именем ShopItem (товар), объекты которого создаются командой:
    item = ShopItem(name, weight, price)
где name - название товара (строка); weight - вес товара (число: целое или вещественное); price - цена товара (число: 
целое или вещественное).
Определите в этом классе магические методы:
    __hash__() - чтобы товары с одинаковым названием (без учета регистра), весом и ценой имели бы равные хэши;
    __eq__() - чтобы объекты с одинаковыми хэшами были равны.
Затем, из входного потока прочитайте строки командой:
    lst_in = list(map(str.strip, sys.stdin.readlines()))
Строки имеют следующий формат:
    название товара 1: вес_1 цена_1
    ...
    название товара N: вес_N цена_N
Например:
    Системный блок: 1500 75890.56
    Монитор Samsung: 2000 34000
    Клавиатура: 200.44 545
    Монитор Samsung: 2000 34000
Как видите, товары в этом списке могут совпадать.
Необходимо для всех этих строчек сформировать соответствующие объекты класса ShopItem и добавить в словарь с именем 
shop_items. Ключами словаря должны выступать сами объекты, а значениями - список в формате:
[item, total]
где item - объект класса ShopItem; total - общее количество одинаковых объектов (с одинаковыми хэшами). Подумайте, 
как эффективно программно наполнять такой словарь, проходя по списку lst_in один раз.
P.S. На экран ничего выводить не нужно, только объявить класс и сформировать словарь.
Sample Input:
    Системный блок: 1500 75890.56
    Монитор Samsung: 2000 34000
    Клавиатура: 200.44 545
    Монитор Samsung: 2000 34000
Sample Output:
"""
import sys


# здесь объявляйте классы
class ShopItem:
    def __init__(self, name, weight, price):
        self.name = name
        self.weight = self.__func(weight)
        self.price = self.__func(price)

    @staticmethod
    def __func(value):
        try:
            return int(value)
        except:
            return float(value)

    def __hash__(self):
        return hash((self.name.lower(), self.weight, self.price))

    def __eq__(self, other):
        return hash(self) == hash(other)


# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in в программе не менять!

shop_items = {}
for i in lst_in:
    i = i.split(': ')
    obj = ShopItem(i[0], *i[1].split())
    shop_items.setdefault(obj, [obj, 0])[-1] += 1


""" Упражнение 3
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/rqCqhjtl6Lw
Подвиг 7. Объявите класс с именем DataBase (база данных - БД), объекты которого создаются командой:
    db = DataBase(path)
где path - путь к файлу с данными БД (строка).
Также в классе DataBase нужно объявить следующие методы:
    write(self, record) - для добавления новой записи в БД, представленной объектом record;
    read(self, pk) - чтение записи из БД (возвращает объект Record) по ее уникальному идентификатору pk (уникальное 
целое положительное число); запись ищется в значениях словаря (см. ниже)
Каждая запись БД должна описываться классом Record, а объекты этого класса создаваться командой:
    record = Record(fio, descr, old)
где fio - ФИО некоторого человека (строка); descr - характеристика человека (строка); old - возраст человека (целое число).
В каждом объекте класса Record должны формироваться следующие локальные атрибуты:
    pk - уникальный идентификатор записи (число: целое, положительное); формируется автоматически при создании каждого 
нового объекта;
    fio - ФИО человека (строка);
    descr - характеристика человека (строка);
    old - возраст человека (целое число).
Реализовать для объектов класса Record вычисление хэша по атрибутам: fio и old (без учета регистра). Если они одинаковы 
для разных записей, то и хэши должны получаться равными. Также для объектов класса Record  с одинаковыми хэшами 
оператор == должен выдавать значение True, а с разными хэшами - False.
Хранить записи в БД следует в виде словаря dict_db (атрибут объекта db класса DataBase), ключами которого являются 
объекты класса Record, а значениями список из объектов с равными хэшами:
    dict_db[rec1] = [rec1, rec2, ..., recN]
где rec1, rec2, ..., recN - объекты класса Record с одинаковыми хэшами.
Для наполнения БД прочитайте строки из входного потока с помощью команды:
    lst_in = list(map(str.strip, sys.stdin.readlines()))
где каждая строка представлена в формате:
    "ФИО; характеристика; возраст"
Например:
    Балакирев С.М.; программист; 33
    Кузнецов А.В.; разведчик-нелегал; 35
    Суворов А.В.; полководец; 42
    Иванов И.И.; фигурант всех подобных списков; 26
    Балакирев С.М.; преподаватель; 37
Каждая строка должна быть представлена объектом класса Record и записана в БД db (в словарь db.dict_db).
P.S. На экран ничего выводить не нужно.
Sample Input:
    Балакирев С.М.; программист; 33
    Кузнецов Н.И.; разведчик-нелегал; 35
    Суворов А.В.; полководец; 42
    Иванов И.И.; фигурант всех подобных списков; 26
    Балакирев С.М.; преподаватель; 33
Sample Output:
"""
import sys


# здесь объявляйте классы
class Record:
    COUNT = 0

    @classmethod
    def count(cls):
        cls.COUNT += 1
        return cls.COUNT

    def __init__(self, fio, descr, old):
        self.fio = fio
        self.descr = descr
        self.old = int(old)
        self.pk = self.count()

    def __hash__(self):
        return hash((self.fio, self.old))

    def __eq__(self, other):
        return hash(self) == hash(other)


class DataBase:
    def __init__(self, path=''):
        self.path = path
        self.dict_db = {}

    def write(self, record):
        self.dict_db.setdefault(record, []).append(record)

    def read(self, pk):
        for v in self.dict_db.values():
            for i in v:
                if i.pk == pk:
                    return i


# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in не менять!

# здесь продолжайте программу (используйте список строк lst_in)
db = DataBase('path')
for i in lst_in:
    db.write(Record(*i.split('; ')))


""" Упражнение 4
Подвиг 8. Из входного потока необходимо прочитать список строк командой:
    lst_in = list(map(str.strip, sys.stdin.readlines()))
Каждая строка содержит информацию об учебном пособии в формате:
    "Название; автор; год издания"
Например:
    Python; Балакирев С.М.; 2020
    Python ООП; Балакирев С.М.; 2021
    Python ООП; Балакирев С.М.; 2022
    Python; Балакирев С.М.; 2021
Необходимо каждую из этих строк представить объектом класса BookStudy, которые создаются командой:
    bs = BookStudy(name, author, year)
где name - название пособия (строка); author - автор пособия (строка); year - год издания (целое число). Такие же 
публичные локальные атрибуты должны быть в объектах класса BookStudy.
Для каждого объекта реализовать вычисление хэша по двум атрибутам: name и author (без учета регистра).
Сформировать список lst_bs из объектов класса BookStudy на основе прочитанных строк (списка lst_in). После этого 
определить число книг с уникальными хэшами. Это число сохранить через переменную unique_books (целое число).
P.S. На экран ничего выводить не нужно.
Sample Input:
    Python; Балакирев С.М.; 2020
    Python ООП; Балакирев С.М.; 2021
    Python ООП; Балакирев С.М.; 2022
    Python; Балакирев С.М.; 2021
Sample Output:
"""
import sys


# здесь объявляйте класс
class BookStudy:
    def __init__(self, name, author, year):
        self.name = name
        self.author = author
        self.year = year

    def __hash__(self):
        return hash((self.name.lower(), self.author.lower()))


# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in не менять!

# здесь продолжайте программу (используйте список строк lst_in)
lst_bs = [BookStudy(*x.split('; ')) for x in lst_in]
unique_books = len(set(hash(x) for x in lst_bs))


""" Упражнение 5
Подвиг 9 (релакс). Объявите класс с именем Dimensions, объекты которого создаются командой:
    d = Dimensions(a, b, c)
где a, b, c - положительные числа (целые или вещественные), описывающие габариты некоторого тела: высота, ширина и глубина.
Каждый объект класса Dimensions должен иметь аналогичные публичные атрибуты a, b, c (с соответствующими числовыми 
значениями). Также для каждого объекта должен вычисляться хэш на основе всех трех габаритов: a, b, c.
С помощью функции input() прочитайте из входного потока строку, записанную в формате:
    "a1 b1 c1; a2 b2 c2; ... ;aN bN cN"
Например:
    "1 2 3; 4 5 6.78; 1 2 3; 0 1 2.5"
Если какой-либо габарит оказывается отрицательным значением или равен нулю, то при создании объектов должна 
генерироваться ошибка командой:
    raise ValueError("габаритные размеры должны быть положительными числами")
Сформируйте на основе прочитанной строки список lst_dims из объектов класса Dimensions. После этого отсортируйте этот 
список по возрастанию (неубыванию) хэшей этих объектов так, чтобы объекты с равными хэшами стояли друг за другом.
P.S. На экран ничего выводить не нужно.
Sample Input:
    1 2 3; 4 5 6.78; 1 2 3; 3 1 2.5
Sample Output:
"""
s_inp = input()  # эту строку (переменную s_inp) в программе не менять


class Dimensions:
    def __init__(self, a, b, c):
        self.a = self.validate(a)
        self.b = self.validate(b)
        self.c = self.validate(c)

    @staticmethod
    def validate(value):
        value = value
        try:
            value = int(value)
        except:
            value = float(value)
        if value <= 0:
            raise ValueError("габаритные размеры должны быть положительными числами")
        return value

    def __lt__(self, other):
        return hash(self) < hash(other)

    def __hash__(self):
        return hash((self.a, self.b, self.c))


lst_dims = [Dimensions(*x.split()) for x in s_inp.split('; ')]
lst_dims.sort()


""" Упражнение 6
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/0EYz8-qG2iU
Подвиг 10 (на повторение). Объявите класс с именем Triangle, объекты которого создаются командой:
    tr = Triangle(a, b, c)
где a, b, c - длины сторон треугольника (числа: целые или вещественные). В классе Triangle объявите следующие дескрипторы данных:
    a, b, c - для записи и считывания длин сторон треугольника.
При записи нового значения нужно проверять, что присваивается положительное число (целое или вещественное). Иначе,
генерируется исключение командой:
    raise ValueError("длины сторон треугольника должны быть положительными числами")
Также нужно проверять, что все три стороны a, b, c могут образовывать стороны треугольника. То есть, должны выполняться условия:
    a < b+c; b < a+c; c < a+b
Иначе генерируется исключение командой:
    raise ValueError("с указанными длинами нельзя образовать треугольник")
Наконец, с объектами класса Triangle должны выполняться функции:
    len(tr) - возвращает периметр треугольника, приведенный к целому значению с помощью функции int();
    tr() - возвращает площадь треугольника (можно вычислить по формуле Герона: s = sqrt(p * (p-a) * (p-b) * (p-c)), 
где p - полупериметр треугольника).
P.S. На экран ничего выводить не нужно, только объявить класс Triangle.
"""


class Number:
    @staticmethod
    def __is_pos_number(value):
        if type(value) not in (int, float) or value <= 0:
            raise ValueError("длины сторон треугольника должны быть положительными числами")

    def __set_name__(self, owner, name):
        self._name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self._name)

    def __set__(self, instance, value):
        self.__is_pos_number(value)
        setattr(instance, self._name, value)


class Triangle:
    a = Number()
    b = Number()
    c = Number()

    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
        self.is_triangle(a, b, c)

    @staticmethod
    def is_triangle(a, b, c):
        lst = sorted([a, b, c])
        if not lst[0] + lst[1] > lst[2]:
            raise ValueError("с указанными длинами нельзя образовать треугольник")

    def __len__(self):
        return int(self.a + self.b + self.c)

    def __call__(self):
        p = len(self) / 2
        return (p * (p - self.a) * (p - self.b) * (p - self.c)) ** 0.5

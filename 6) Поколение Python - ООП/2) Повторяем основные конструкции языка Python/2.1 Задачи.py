""" Упражнение 1
Будем считать, что игровое поле для игры в дартс представляет собой квадратную матрицу, заполненную натуральными
числами, расположенными в порядке возрастания от краев к центру. Стороной игрового поля будем называть сторону
квадратной матрицы, которую представляет это поле.
Напишите программу, которая создает поле для игры в дартс определенного размера.
Формат входных данных
На вход программе подается единственное натуральное число — сторона игрового поля.
Формат выходных данных
Программа должна создать и вывести игровое поле с заданной стороной.
Примечание 1. Гарантируется, что сторона игрового поля не превышает 18.
Sample Input 1: 1
Sample Output 1:
1
Sample Input 2: 2
Sample Output 2:
1 1
1 1
Sample Input 3: 3
Sample Output 3:
1 1 1
1 2 1
1 1 1
Sample Input 4: 4
Sample Output 4:
1 1 1 1
1 2 2 1
1 2 2 1
1 1 1 1
Sample Input 5: 5
Sample Output 5:
1 1 1 1 1
1 2 2 2 1
1 2 3 2 1
1 2 2 2 1
1 1 1 1 1
"""
def create_matrix(value: int) -> list:
    matrix = [[1 for _ in range(value)] for _ in range(value)]
    for x in range(value):
        for i in range(value):
            for j in range(value):
                if 0 + x < i < value - x - 1 and 0 + x < j < value - x - 1:
                    matrix[i][j] += 1
    return matrix

for row in create_matrix(int(input())):
    print(*row)


""" Упражнение 2
Назовем скобочной последовательностью строку, состоящую из символов ( и ). Будем считать скобочную последовательность 
правильной, если:
    для каждой открывающей скобки есть закрывающая скобка
    скобки закрываются в правильном порядке, то есть в каждой паре из открывающей и закрывающей скобок открывающая 
находится левее
Напишите программу, которая определяет, является ли скобочная последовательность правильной.
Формат входных данных
На вход программе подается строка, представляющая собой скобочную последовательность.
Формат выходных данных
Программа должна вывести True, если введенная скобочная последовательность является правильной, или False в противном 
случае.
Sample Input 1: ()()()
Sample Output 1: True
Sample Input 2: (())
Sample Output 2: True
Sample Input 3: ()()()(
Sample Output 3: False
Sample Input 4: )(
Sample Output 4: False
Sample Input 5: (()))
Sample Output 5: False
"""
def is_correct_bracket(text):
    c = 0
    for i in text:
        if c < 0:
            return False
        if i == '(':
            c += 1
        if i == ')':
            c -= 1
    return c == 0
# считываем данные
txt = input()

# вызываем функцию
print(is_correct_bracket(txt))


""" Упражнение 3
Дана последовательность чисел [a1, a2,..., an]. Назовем пару (ai, aj) инверсией, если i<j, а ai > aj. Например, 
последовательность 3,1,4,2 имеет три инверсии (3,1),(3,2),(4,2). Каждая инверсия — это пара элементов, нарушающих 
порядок.
Реализуйте функцию inversions(), которая принимает один аргумент:
    sequence — последовательность, элементами которой являются числа
Функция должна возвращать единственное число — количество инверсий в последовательности sequence.
Примечание 1. Последовательностью будем считать объект, имеющий длину и поддерживающий индексацию. Например, объекты 
типа list или range являются последовательностями.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию inversions(), но не код, 
вызывающий ее.
Sample Input 1:
sequence = [3, 1, 4, 2]

print(inversions(sequence))
Sample Output 1: 3
Sample Input 2:
sequence = [1, 2, 3, 4, 5]

print(inversions(sequence))
Sample Output 2:0
Sample Input 3:
sequence = [4, 3, 2, 1]

print(inversions(sequence))
Sample Output 3:6
Sample Input 4:
sequence = [1, 1, 1, 1, 1, 1]

print(inversions(sequence))
Sample Output 4: 0
"""
def inversions(seq):
    count = 0
    for i in range(len(seq)):
        for j in range(len(seq)):
            if i < j and seq[i] > seq[j]:
                count += 1
    return count


""" Упражнение 4
Артур владеет небольшой коллекцией карточек с покемонами, среди которых встречаются дубликаты. Он хочет оставить 
по одной карточке каждого типа, а остальные продать.
Напишите программу, которая определяет, сколько дубликатов из своей коллекции Артур может продать.
Формат входных данных
На вход программе подается произвольное количество строк, которые представляют коллекцию карточек с покемонами. 
В каждой строке указывается имя покемона с карточки.
Формат выходных данных
Программа должна вывести единственное число — количество карточек, которые из данной коллекции можно продать, чтобы 
оставить по одной карточке каждого типа.
Примечание 1. Рассмотрим первый тест. Чтобы оставить по одной карточке каждого типа, достаточно продать две карточки 
Pichu и одну карточку Tyrogue.
Sample Input 1:
    Pichu
    Pichu
    Tyrogue
    Pichu
    Combee
    Marill
    Tyrogue
Sample Output 1: 3
Sample Input 2:
    Tyrogue
    Pichu
    Combee
Sample Output 2: 0
"""
import sys

lst = [x.strip('\n') for x in sys.stdin]
print(len(lst) - len(set(lst)))


""" Упражнение 5
Реализуйте декоратор @jsonify, преобразующий возвращаемое значение декорируемой функции в строку формата JSON.
Также декоратор должен сохранять имя и строку документации декорируемой функции.
Примечание 1. Гарантируется, что возвращаемое значение функции принадлежит типу, который поддерживается форматом JSON.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимый декоратор @jsonify, но не код, 
вызывающий его.
Sample Input 1:
    @jsonify
    def make_user(id, live, options):
        return {'id': id, 'live': live, 'options': options}
        
    print(make_user(4, False, None))
Sample Output 1:
    {"id": 4, "live": false, "options": null}
Sample Input 2:
    @jsonify
    def make_list(n):
        return list(range(1, n + 1))
        
    print(make_list(10))
Sample Output 2:
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Sample Input 3:
    @jsonify
    def make_str(s1, s2):
        return (s1 + s2) * 5
        
    print(make_str('bee', 'geek'))
Sample Output 3:
    "beegeekbeegeekbeegeekbeegeekbeegeek"
"""
import json


def jsonify(func):
    def wrapper(*args, **kwargs):
        return json.dumps(func(*args, **kwargs))
    wrapper.__name__ = func.__name__
    wrapper.__doc__ = func.__doc__
    return wrapper


""" Упражнение 6
Географические координаты представляют собой пару чисел (x,y), где x — широта, y — долгота, причем −90°≤x≤90°, 
−180°≤y≤180°.
Напишите программу, которая принимает произвольное количество строк и определяет, какие из них представляют собой 
корректные географические координаты.
Формат входных данных
На вход программе подается произвольное количество строк, каждая из которых представляет собой пару чисел в следующем 
формате:
    (<координата x>, <координата y>)
Формат выходных данных
Программа должна для каждой строки вывести True, если она представляет собой корректные географические координаты, 
или False в противном случае.
Sample Input 1:
    (75, 180)
    (90, -147.45)
    (77.111, 149.9999)
    (90, 180)
    (55.1, 249.9)
    (120, 150)
Sample Output 1:
    True
    True
    True
    True
    False
    False
Sample Input 2:
    (-90, -180)
    (-90.0, -180.0)
    (-90, 180)
    (90, -180)
    (90.0, 180.0)
Sample Output 2:
    True
    True
    True
    True
    True
Sample Input 3:
    (-90.1, 1)
    (-90.2, 45)
    (10, 180.01)
    (1, 180.0004)
Sample Output 3:
    False
    False
    False
    False
"""
import sys


for line in sys.stdin:
    x, y = map(float, line.strip('\n')[1:-1].split(', '))
    print(-90 <= x <= 90 and -180 <= y <= 180)


""" Упражнение 7
Реализуйте функцию quantify(), которая принимает два аргумента в следующем порядке:
iterable — итерируемый объект
predicate — функция-предикат, то есть функция, возвращающая True или False. Если имеет значение None, то работает 
аналогично функции bool()
Функция quantify() должна считать, для скольких элементов итерируемого объекта iterable функция-предикат predicate 
вернула значение True, и возвращать полученный результат.
Примечание 1. Рассмотрим первый тест, в котором в качестве итерируемого объекта передается список чисел от 1 до 10, 
в качестве функции-предиката — функция, возвращающая True, если аргумент больше единицы, или False в противном случае. 
Переданный список чисел содержит ровно 9 чисел, больших единицы.
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию quantify(), но не код, 
вызывающий ее.
Примечание 3. Тестовые данные доступны по ссылкам:
Sample Input 1:
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    
    print(quantify(numbers, lambda x: x > 1))
Sample Output 1: 9
Sample Input 2:
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    
    print(quantify(numbers, lambda x: x % 2 == 0))
Sample Output 2: 5
Sample Input 3:
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    
    print(quantify(numbers, lambda x: x < 0))
Sample Output 3: 0
"""
def quantify(iterable, predicate):
    if predicate is None:
        predicate = bool
    return sum(1 for x in iterable if predicate(x))


""" Упражнение 8
Каждый месяц в Сан-Диего организовывается встреча любителей Python, которая проходит в четвертый четверг месяца.
Напишите программу, которая определяет день проведения очередной встречи питонистов в Сан-Диего.
Формат входных данных
На вход программе подается два натуральных числа, представляющие год и месяц, каждое на отдельной строке.
Формат выходных данных
Программа должна определить день проведения встречи в Сан-Диего в указанных году и месяце и вывести результат 
в формате DD.MM.YYYY.
Примечание 1. Гарантируется, что подаваемые год и месяц всегда корректны.
Sample Input 1:
    2012
    3
Sample Output 1: 22.03.2012
Sample Input 2:
    2015
    2
Sample Output 2: 26.02.2015
Sample Input 3:
    2018
    6
Sample Output 3: 28.06.2018
"""
import calendar

year, month = int(input()), int(input())
month_matrix = calendar.monthcalendar(year, month)
date = month_matrix[3][3]
if month_matrix[0][3] == 0:
    date = month_matrix[4][3]
print(f'{date}.{str(month).rjust(2, "0")}.{year}')


""" Упражнение 9
Целым числом будем считать последовательность из одной или более цифр, которая может начинаться с необязательного 
символа дефиса -.
Реализуйте функцию is_integer(), которая принимает один аргумент:
    string — строка, содержащая произвольный набор символов
Функция должна возвращать True, если строка string представляет собой целое число, или False в противном случае.
Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию is_integer(), но не код, 
вызывающий ее.
Sample Input 1: print(is_integer('199'))
Sample Output 1: True
Sample Input 2: print(is_integer('-43'))
Sample Output 2: True
Sample Input 3: print(is_integer('5f'))
Sample Output 3: False
Sample Input 4: print(is_integer('5.0'))
Sample Output 4: False
Sample Input 5: print(is_integer('1.1'))
Sample Output 5: False
"""
import re


def is_integer(string):
    return bool(re.fullmatch(r'-?\d+', string))


""" Упражнение 10
Будем считать вещественным числом последовательность из одной или более цифр, которая может начинаться с 
необязательного символа дефиса -, а также содержать на любой позиции одну десятичную точку ., кроме случая, когда точка 
стоит перед символом дефиса.
Реализуйте функцию is_decimal(), которая принимает один аргумент:
    string — строка, содержащая произвольный набор символов
Функция должна возвращать True, если строка string представляет собой целое или вещественное число, или False 
в противном случае.
Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию is_decimal(), но не код, 
вызывающий ее.
Sample Input 1: print(is_decimal('100'))
Sample Output 1: True
Sample Input 2: print(is_decimal('199.1'))
Sample Output 2: True
Sample Input 3: print(is_decimal('-0.2'))
Sample Output 3:True
Sample Input 4: print(is_decimal('.-95'))
Sample Output 4: False
Sample Input 5: print(is_decimal('-.95'))
Sample Output 5: True
Sample Input 6: print(is_decimal('.10'))
Sample Output 6: True
"""
import re


def is_decimal(string):
    return bool(re.fullmatch(r'-?(?:\d+\.?(\d+)?|(\d+)?\.?\d+)', string))


""" Упражнение 11
Будем считать обыкновенной дробью последовательность из одной или более цифр, за которой следует прямая косая черта /, 
а затем — последовательность из одной или более цифр, хотя бы одна из которых отлична от нуля (знаменатель не может 
равняться нулю). Последовательность, представляющая собой обыкновенную дробь, может начинаться с необязательного 
символа дефиса -.
Реализуйте функцию is_fraction(), которая принимает один аргумент:
    string — строка, содержащая произвольный набор символов
Функция должна возвращать True, если строка string представляет собой обыкновенную дробь, или False в противном случае.
Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию is_fraction(), но не код, 
вызывающий ее.
Sample Input 1: print(is_fraction('1000/1'))
Sample Output 1: True
Sample Input 2: print(is_fraction('-54/9'))
Sample Output 2: True
Sample Input 3: print(is_fraction('71'))
Sample Output 3: False
Sample Input 4: print(is_fraction('1 / 82'))
Sample Output 4: False
Sample Input 5: print(is_fraction('1/0'))
Sample Output 5: False
"""
import re

def is_fraction(string):
    return bool(re.fullmatch(r'-?\d+/(?:0+[1-9]+0*|[1-9]+\d*)', string))


""" Упражнение 12
Реализуйте генераторную функцию intersperse(), которая принимает два аргумента в следующем порядке:
    iterable — итерируемый объект
    delimiter — значение-разделитель
Функция должна возвращать генератор, порождающий последовательность из элементов итерируемого объекта iterable,
между которыми располагается значение-разделитель delimiter.
Примечание 1. Рассмотрим первый тест, в котором в качестве итерируемого объекта передается список чисел от 1 до 3, 
а в качестве значения-разделителя — 0. Порождаемая генератором последовательность состоит из чисел 1, 2 и 3, между 
которыми располагается число 0: 1 0 2 0 3
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию intersperse(), но не код, 
вызывающий ее.
Sample Input 1: print(*intersperse([1, 2, 3], 0))
Sample Output 1: 1 0 2 0 3
Sample Input 2:
    inter = intersperse('beegeek', '!')
    print(next(inter))
    print(next(inter))
    print(*inter)
Sample Output 2:
    b
    !
    e ! e ! g ! e ! e ! k
Sample Input 3: print(*intersperse('A', '...'))
Sample Output 3: A
"""
def intersperse(iterable, delimiter):
    iterable = tuple(iterable)
    for i in iterable:
        yield i
        if i != iterable[-1]:
            yield delimiter


""" Упражнение 13 
Практически каждый человек знаком с финансовыми инвестициями, целью которых является преумножение имеющихся средств 
в течение некоторого времени. Наиболее простым примером является банковский вклад, который ежегодно увеличивается путем 
начисления на него определенного числа процентов. Составляющими такого банковского вклада являются начальная сумма 
вклада, процентная ставка и срок вклада.
Чтобы понять, каким образом меняется размер вклада и происходит начисление процентов, рассмотрим следующую задачу: 
Вкладчик открыл счёт в банке, разместив сумму в 120000 рублей под 10% годовых. Какая сумма будет на счёте через 3 года?
Решение. В конце каждого года размер вклада увеличивается на 10%. Согласно условию задачи имеем:
Размер вклада после 1-го начисления: 120000 ⋅ 11/10 = 132000
Размер вклада после 2-го начисления: 132000 ⋅ 11/10 = 145200
Размер вклада после 3-го начисления: 145200 ⋅ 11/10 = 159720
Ответ: 159720 рублей.
Реализуйте генераторную функцию annual_return(), которая принимает три аргумента в следующем порядке:
    start — целое число, начальная сумма вклада в рублях
    percent — целое число, процент, на который текущая сумма вклада будет увеличиваться каждый год
    years — целое число, количество лет, в течение которых будут начисляться проценты
Функция должна возвращать итератор, моделирующий банковский вклад. Возвращаемыми значениями итератора должны являться 
размеры вклада после очередного начисления процентов percent.
Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию annual_return(), но не код, 
вызывающий ее.
Sample Input 1:
    for value in annual_return(120000, 10, 3):
        print(round(value))
Sample Output 1:
    132000
    145200
    159720
Sample Input 2:
    for value in annual_return(70000, 8, 10):
        print(round(value))
Sample Output 2:
    75600
    81648
    88180
    95234
    102853
    111081
    119968
    129565
    139930
    151125
"""
def annual_return(start, percent, years):
    for _ in range(years):
        start = start * (100 + percent) / 100
        yield start


""" Упражнение 14
Реализуйте функцию pluck(), которая принимает три аргумента в следующем порядке:
    data — словарь произвольной вложенности
    path — строка, представляющая собой ключ или последовательность ключей, перечисленных через точку .
    default — произвольный объект, значение по умолчанию; имеет значение None, если не передан явно
Функция должна возвращать значение по ключу path из словаря data. Если path представляет собой последовательность 
ключей, например, key1.key2, то возвращаемым значением функции должно быть значение по ключу key2 из словаря data[key1]. 
Если указанного ключа или хотя бы одного ключа из последовательности ключей в словаре нет, функция должна вернуть 
значение default.
Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию pluck(), но не код, 
вызывающий ее.
Sample Input 1:
    d = {'a': {'b': 5, 'z': 20}, 'c': {'d': 3}, 'x': 40}
    
    print(pluck(d, 'x'))
Sample Output 1: 40
Sample Input 2:
    d = {'a': {'b': 5, 'z': 20}, 'c': {'d': 3}, 'x': 40}
    
    print(pluck(d, 'a.b'))
Sample Output 2: 5
Sample Input 3: 
    d = {'a': {'b': {'c': {'d': {'e': 4}}}}}
    
    print(pluck(d, 'a.b.c'))
Sample Output 3: {'d': {'e': 4}}
"""
def pluck(data, path, default=None):
    path = path.split('.')
    while path:
        data = data.get(path.pop(0), default)
    return data


""" Упражнение 15
Реализуйте декоратор @recviz, который полностью визуализирует выполнение декорируемой функции, в том числе и 
рекурсивной. Декоратор должен отображать все рекурсивные вызовы и возвращаемые значения, полученные при этих вызовах, 
причем рекурсивные вызовы, выполняемые в глубину, должны отделяться друг от друга четырьмя пробелами.
Очередной вызов декорируемой функции при визуализации должен включать в себя знак ->, имя декорируемой функции и 
аргументы, переданные при этом вызове. Возвращаемое значение при визуализации должно включать в себя знак <- и 
непосредственно само возвращаемое значение.
Примечание 1. Рекурсивный вызов и возвращаемое значение, полученное при этом вызове, должны находиться на одном уровне 
отступов.
Примечание 2. Не забывайте, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также 
должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимый декоратор @recviz, но не код, 
вызывающий его.
Sample Input 1:
    @recviz
    def add(a, b):
        return a + b
    
    add(1, b=2)
Sample Output 1:
    -> add(1, b=2)
    <- 3
Sample Input 2:
    @recviz
    def add(a, b, c, d, e):
        return (a + b + c) * (d + e)
    
    add('a', b='b', c='c', d=3, e=True)
Sample Output 2:
    -> add('a', b='b', c='c', d=3, e=True)
    <- 'abcabcabcabc'
Sample Input 3:
    @recviz
    def fib(n):
        if n <= 2:
            return 1
        else:
            return fib(n - 1) + fib(n - 2)
            
    fib(4)
Sample Output 3:
    -> fib(4)
        -> fib(3)
            -> fib(2)
            <- 1
            -> fib(1)
            <- 1
        <- 2
        -> fib(2)
        <- 1
    <- 3
Sample Input 4:
    @recviz
    def fact(n):
        if n == 0:
            return 1
        else:
            return n*fact(n-1)
            
    fact(5)
Sample Output 4:
    -> fact(5)
        -> fact(4)
            -> fact(3)
                -> fact(2)
                    -> fact(1)
                        -> fact(0)
                        <- 1
                    <- 1
                <- 2
            <- 6
        <- 24
    <- 120
"""
def recviz(func):
    func.__dict__['count'] = 0
    def wrapper(*args, **kwargs):
        arg_list = [repr(x) for x in args]
        arg_list.extend(f'{k}={repr(v)}' for k,v in kwargs.items())
        print(f'{" "*func.__dict__["count"]}->', f'{func.__name__}({", ".join(arg_list)})')
        func.__dict__['count'] += 4
        res = func(*args, **kwargs)
        func.__dict__['count'] -= 4
        print(f'{" "*func.__dict__["count"]}<-', repr(res))
        return res
    return wrapper

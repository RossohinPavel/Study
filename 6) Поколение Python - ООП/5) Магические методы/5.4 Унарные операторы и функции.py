""" Упражнение 1
Реализуйте класс ReversibleString, описывающий строку. При создании экземпляра класс должен принимать один аргумент:
    string — значение строки
Экземпляр класса ReversibleString должен иметь следующее неформальное строковое представление:
    <значение строки>
Также экземпляр класса ReversibleString должен поддерживать унарный оператор -, результатом которого должен являться
новый экземпляр класса ReversibleString со значением строки в обратном порядке.
Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс
используется только с корректными данными.
Примечание 2. Никаких ограничений касательно реализации класса ReversibleString нет, она может быть произвольной.
Sample Input:
    string = ReversibleString('python')

    print(string)
    print(-string)
Sample Output:
    python
    nohtyp
"""
class ReversibleString:
    def __init__(self, string):
        self.string = string

    def __str__(self):
        return self.string

    def __neg__(self):
        return ReversibleString(self.string[::-1])


""" Упражнение 2
Реализуйте класс Money, описывающий денежную сумму в рублях. При создании экземпляра класс должен принимать один аргумент:
    amount — количество денег
Экземпляр класса Money должен иметь следующее неформальное строковое представление:
    <количество денег> руб.
Также экземпляр класса Money должен поддерживать унарные операторы + и -:
    результатом унарного + должен являться новый экземпляр класса Money с неотрицательным количеством денег
    результатом унарного - должен являться новый экземпляр класса Money с отрицательным количеством денег
Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс
используется только с корректными данными.
Примечание 2. Никаких ограничений касательно реализации класса Money нет, она может быть произвольной.
Sample Input 1:
    money = Money(100)
    
    print(money)
    print(+money)
    print(-money)
Sample Output 1:
    100 руб.
    100 руб.
    -100 руб.
Sample Input 2:
    money = Money(-100)
    
    print(money)
    print(+money)
    print(-money)
Sample Output 2:
    -100 руб.
    100 руб.
    -100 руб.
"""
class Money:
    def __init__(self, money):
        self.money = money

    def __str__(self):
        return str(self.money) + ' руб.'

    def __pos__(self):
        return Money(abs(self.money))

    def __neg__(self):
        return Money(self.money if self.money < 0 else -self.money)


""" Упражнение 3
Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента 
в следующем порядке:
    x — координата вектора по оси x
    y — координата вектора по оси y
Экземпляр класса Vector должен иметь следующее формальное строковое представление:
    Vector(<координата x>, <координата y>)
И следующее неформальное строковое представление:
    (<координата вектора по оси x>, <координата вектора по оси y>)
Также экземпляр класса Vector должен поддерживать унарные операторы + и -:
    результатом унарного + должен являться новый экземпляр класса Vector с исходными координатами
    результатом унарного - должен являться новый экземпляр класса Vector с координатами, взятыми с противоположным знаком
Наконец, при передаче экземпляра класса Vector в функцию abs() должен возвращаться его модуль.
Примечание 1. Модуль вектора с координатами x, y вычисляется по формуле (self.x ** 2 + self.y ** 2) ** 0.5
Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс 
используется только с корректными данными.
Примечание 3. Никаких ограничений касательно реализации класса Vector нет, она может быть произвольной.
Sample Input:
    vector = Vector(3, -4)
    
    print(+vector)
    print(-vector)
    print(abs(vector))
Sample Output:
    (3, -4)
    (-3, 4)
    5.0
"""
class Vector:
    def __init__(self, x, y):
        self.x, self.y = x, y

    def __repr__(self):
        return f'Vector{self.x, self.y}'

    def __str__(self):
        return f'{self.x, self.y}'

    def __pos__(self):
        return Vector(self.x, self.y)

    def __neg__(self):
        form = lambda x: -x if x > 0 else abs(x)
        return Vector(form(self.x), form(self.y))

    def __abs__(self):
        return (self.x ** 2 + self.y ** 2) ** 0.5


""" Упражнение 4
Реализуйте класс ColoredPoint, описывающий цветную точку на плоскости. При создании экземпляра класс должен принимать 
три аргумента в следующем порядке:
    x — координата точки по оси x
    y — координата точки по оси y
    color — цвет в формате RGB, представленный кортежем из трех целых чисел в диапазоне [0; 255], по умолчанию имеет 
значение (0, 0, 0)
Экземпляр класса ColoredPoint должен иметь три атрибута:
    x — координата точки по оси x
    y — координата точки по оси y
    color — цвет в формате RGB, представленный кортежем из трех целых чисел от 0 до 255
Также экземпляр класса ColoredPoint должен иметь следующее формальное строковое представление:
    ColoredPoint(<координата x>, <координата y>, <цвет точки в виде трехэлементного кортежа>)
И следующее неформальное строковое представление:
    (<координата x>, <координата y>)
Наконец, экземпляр класса ColoredPoint должен поддерживать унарные операторы +, - и ~:
    результатом унарного + должен являться новый экземпляр класса ColoredPoint c исходными координатами и цветом
    результатом унарного - должен являться новый экземпляр класса ColoredPoint c координатами, умноженными на минус 
единицу, и исходным цветом
    результатом унарного ~ должен являться новый экземпляр класса ColoredPoint c координатами, переставленными местами, 
и инвертированным цветом: значение каждой компоненты цвета отнимается от 255
Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс 
используется только с корректными данными.
Примечание 2. Никаких ограничений касательно реализации класса ColoredPoint нет, она может быть произвольной.
Sample Input 1:
    point = ColoredPoint(2, -3)
    
    print(+point)
    print(-point)
    print(~point)
Sample Output 1:
    (2, -3)
    (-2, 3)
    (-3, 2)
Sample Input 2:
    point1 = ColoredPoint(2, -3)
    point2 = ColoredPoint(10, 20, (34, 45, 67))
    
    print(point1.color)
    print(point2.color)
Sample Output 2:
    (0, 0, 0)
    (34, 45, 67)
"""
class ColoredPoint:
    def __init__(self, x, y, color=(0, 0, 0)):
        self.x, self.y = x, y
        self.color = color

    def __repr__(self):
        return f'ColoredPoint{self.x, self.y, self.color}'

    def __str__(self):
        return f'{self.x, self.y}'

    def __pos__(self):
        return eval(repr(self))

    def __neg__(self):
        return ColoredPoint(-1 * self.x, -1 * self.y, self.color)

    def __invert__(self):
        return ColoredPoint(self.y, self.x, tuple(255 - self.color[i] for i in range(3)))


""" Упражнение 5
Реализуйте класс Matrix, описывающий двумерную матрицу. При создании экземпляра класс должен принимать три аргумента 
в следующем порядке:
    rows — количество строк в матрице
    cols — количество столбцов в матрице
    value — начальное значение для элементов матрицы, по умолчанию имеет значение 0
Экземпляр класса Matrix должен иметь два атрибута:
    rows — количество строк в матрице
    cols — количество столбцов в матрице
Класс Matrix должен иметь два метода экземпляра:
    get_value() — метод, принимающий в качестве аргументов строку row и столбец col и возвращающий элемент матрицы со 
строкой row и столбцом col
    set_value() — метод, принимающий в качестве аргументов строку row, столбец col и значение value и устанавливающий 
в качестве значения элемента матрицы со строкой row и столбцом col значение value
Экземпляр класса Matrix должен иметь следующее формальное строковое представление:
    Matrix(<количество строк в матрице>, <количество столбцов в матрице>)
Неформальным строковым представлением должна быть строка, в которой перечислены все элементы матрицы. Элементы строки 
матрицы должны быть разделены пробелом, строки матрицы должны быть разделены символом переноса строки \n. Например, для 
объекта Matrix(2, 3) неформальным строковым представлением должна быть строка 0 0 0\n0 0 0, которая при выводе будет 
отображаться следующим образом:
    0 0 0
    0 0 0
Также экземпляр класса Matrix должен поддерживать унарные операторы +, - и ~:
    результатом унарного + должен являться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с 
исходными элементами
    результатом унарного - должен являться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с 
элементами, взятыми с противоположным знаком
    результатом унарного ~ должен являться новый экземпляр класса Matrix, представляющий транспонированную матрицу
Наконец, при передаче экземпляра класса Matrix в функцию round() должен возвращаться новый экземпляр класса Matrix c 
исходным количеством строк и столбцов и с элементами, округленными с помощью функции round(). Во время передачи в 
функцию round() должна быть возможность в качестве второго необязательного аргумента указать целое число, определяющее 
количество знаков после запятой при округлении.
Примечание 1. Индексация строк и столбцов в матрице начинается с нуля.
Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс 
используется только с корректными данными.
Примечание 3. Никаких ограничений касательно реализации класса Matrix нет, она может быть произвольной.
Sample Input 1:
    print(Matrix(2, 3))
Sample Output 1:
    0 0 0
    0 0 0
Sample Input 2:
    matrix = Matrix(2, 3, 1)
    
    print(+matrix)
    print()
    print(-matrix)
Sample Output 2:
    1 1 1
    1 1 1
    
    -1 -1 -1
    -1 -1 -1
Sample Input 3:
    matrix = Matrix(2, 3, 1)
    
    print(matrix)
    print()
    print(~matrix)
Sample Output 3:
    1 1 1
    1 1 1
    
    1 1
    1 1
    1 1
"""
class Matrix:
    def __init__(self, rows, cols, value=0):
        self.rows = rows
        self.cols = cols
        self._matrix = [[value] * cols for _ in range(rows)]

    @classmethod
    def from_matrix(cls, matrix):
        base = cls(len(matrix), len(matrix[0]))
        base._matrix = matrix
        return base

    def get_value(self, row, col):
        return self._matrix[row][col]

    def set_value(self, row, col, value):
        self._matrix[row][col] = value

    def __repr__(self):
        return f'Matrix{self.rows, self.cols}'

    def __str__(self):
        return '\n'.join(' '.join(str(i) for i in r) for r in self._matrix)

    def __pos__(self):
        return Matrix.from_matrix([x.copy() for x in self._matrix])

    def __neg__(self):
        return Matrix.from_matrix([[-i for i in r] for r in self._matrix])

    def __invert__(self):
        return Matrix.from_matrix([[self.get_value(j, i) for j in range(self.rows)] for i in range(self.cols)])

    def __round__(self, nums=1):
        return Matrix.from_matrix([[round(i, nums) for i in r] for r in self._matrix])

""" Упражнение 1
Подвиг 4. Объявите функцию представления с именем post_detail и одним параметром request. 
В этой функции выполните проверку наличия параметров в GET-запросе и если они есть, функция 
должна вернуть их в виде HTTP-ответа со строкой в формате:
ключ_1=значение_1|ключ_2=значение_2|...
(все без пробелов, в конце вертикальная черта стоять не должна, только между парами).
Если GET-параметров передано не было, то функция post_detail() должна вернуть HTTP-ответ 
со строкой "GET is empty".
P.S. Функцию вызывать не нужно, только объявить.
"""
from django.http import HttpResponse, HttpRequest, QueryDict

# здесь объявляйте функцию
def post_detail(r):
    if r.GET:
        return HttpResponse('|'.join(f'{k}={v}' for k, v in r.GET.items()))
    return HttpResponse('GET is empty')


""" Упражнение 2
Подвиг 11. Объявите функцию представления с именем posts_list, которая связана со следующим маршрутом:
urlpatterns = [
    ...
    path('posts/<int:year>', posts_list),
]
(Функция должна корректно срабатывать для него.) Внутри функции выполните проверку на корректность 
переданного года. Если он выходит за пределы [1990; 2023], то вызывать исключение 404 для отображения 
страницы с кодом 404. Если же год указан верно, то функция posts_list должна возвращать HTTP-ответ 
со строкой в формате:
"posts: <year>"
Например, для года 2023 должна возвращаться строка (в объекте HTTP-ответа):
"posts: 2023"
P.S. Функцию вызывать не нужно, только объявить.
"""
from django.http import HttpResponse, HttpRequest, Http404


# здесь объявляйте функцию
def posts_list(r, year):
    if 1990 <= int(year) <= 2023:
        return HttpResponse(f'posts: {year}')

    raise Http404()
